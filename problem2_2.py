# -*- coding: utf-8 -*-
"""Problem2_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V3L-CNTN6az9DeKEhHtq3aa2Gm7NSUy4
"""

import multiprocessing
import random
from math import pi
import time
import random
import time
from multiprocessing import Manager
import matplotlib.pyplot as plt

def sample_pi(n, seed, result_queue):
    random.seed(seed)
    s = 0
    for i in range(n):
        x = random.random()
        y = random.random()
        if x**2 + y**2 <= 1.0:
            s += 1
    result_queue.put(s)

def compute_pi_parallel(accuracy_goal, num_processes, max_iterations=100):
    manager = Manager()
    result_queue = manager.Queue()
    total_samples = 0
    pi_estimate = 0.0

    iterations = 0
    convergence_values = []
    samples_per_second_values = []

    with multiprocessing.Pool(processes=num_processes) as pool:
        start_time = time.time()

        while iterations < max_iterations:
            seeds = [random.randint(1, 100000) for _ in range(num_processes)]
            n_samples = 10000  # Number of samples per process
            total_samples += n_samples * num_processes

            # Distribute tasks to workers
            tasks = [(n_samples, seed, result_queue) for seed in seeds]
            pool.starmap(sample_pi, tasks)

            # Collect results from workers
            successes = sum(result_queue.get() for _ in range(num_processes))
            pi_estimate = (4.0 * successes) / total_samples

            # Check accuracy goal
            if abs(pi - pi_estimate) < accuracy_goal:
                break

            # Update convergence and speedup values
            iterations += 1
            end_time = time.time()
            elapsed_time = end_time - start_time
            samples_per_second = total_samples / elapsed_time

            convergence_values.append(abs(pi - pi_estimate))
            samples_per_second_values.append(samples_per_second)

    return pi_estimate, convergence_values, samples_per_second_values

def plot_convergence_speedup(convergence_values, samples_per_second_values):
    plt.figure(figsize=(10, 6))

    # Plot Convergence
    plt.subplot(2, 1, 1)
    plt.plot(range(1, len(convergence_values) + 1), convergence_values, marker='o')
    plt.title('Convergence Speed')
    plt.xlabel('Iterations')
    plt.ylabel('Absolute Difference from True Pi')

    # Plot Speedup
    plt.subplot(2, 1, 2)
    plt.plot(range(1, len(samples_per_second_values) + 1), samples_per_second_values, marker='o')
    plt.title('Speedup')
    plt.xlabel('Iterations')
    plt.ylabel('Samples per Second')

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    accuracy_goal = 0.0001  # Set your desired accuracy goal
    num_processes = 4  # Set the number of processes

    _, convergence_values, samples_per_second_values = compute_pi_parallel(accuracy_goal, num_processes)
    plot_convergence_speedup(convergence_values, samples_per_second_values)